# 第一节 世界杯竞猜（solidity）



## 内容概述

通过学习，初步了解以太坊开发的基础工具链，通过一个案例（世界杯精彩）实战，使大家掌握基本的solidity开发，完成语法学习。

1. [点击查看效果](https://solidity-expert.vercel.app/)
2. [点击获取代码](https://github.com/dukedaily/solidity-expert/blob/main/08_项目实战-世界杯竞猜/worldcup/contracts/contracts/WorldCup.sol)



## 学习目标

- Metamask：助记词、私钥、地址、gas费相关
- Remix：部署、交互、abi、bytecode
- Etherscan：交易分析、verify合约
- 基础solidity语法：基础类型、如何转账、可见性、手续费、Event



## 业务需求

1. 参赛球队一经设定不可改变，整个活动结束后无法投票；
2. 全⺠均可参与，无权限控制；
3. 每次投票为1ether，且只能选择一支球队；
4. 每个人可以投注多次；
5. 仅管理员公布最终结果，完成奖金分配，开奖后逻辑：
6. winner共享整个奖金池（一部分是自己的本金，一部分是利润）；
7. winner需自行领取奖金（因为有手续费）；
8. 下一期自行开始

### 最初状态

![流程图a](assets/流程图a.jpg)

### 开始投票

![流程图b](assets/流程图b.jpg)

### 开奖后

![流程图c](assets/流程图c.jpg)

## 需求分析

1. 状态变量(真正上链）：管理员、记录所有玩家、统计每个球队参与者、记录获奖者信息、第几期、参赛球队
2. 核心方法：投票、开奖、领奖
3. 辅助方法：获取奖金池金额、管理员地址、当前期数、参与人数、所有玩家、参赛球队



## 知识点

1. 1 ether = 10^18wei, 

2. 1 gwei = 10^9 wei

3. 1 ether = 10^9 gwei

4. tx：

   ```js
   1. from：交易发起人， 合约中是：msg.sender
   2. to：交互合约地址，传给合约的数据：msg.data
   3. value：传递的金额，msg.value
   ```

5. **"storage", "memory"** 

   1. Storage: 引用传值，修改会同步修改原变量
   2. **memory：值传递，完全独立的拷贝**



## 代码

- goerli地址：0x9E896316F0610Cb053C62377601F64c909668334

- https://goerli.etherscan.io/address/0x9e896316f0610cb053c62377601f64c909668334#writeContract

```JavaScript
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "hardhat/console.sol";

// 没有main函数
contract Hellworld {
    // 合约之内，函数之外的字段，状态变量，真正上链的数据
    string private  gretting;

    // 写数据，花钱
    function setGreeting(string memory _greeting) public {
        gretting = _greeting;
    }

    // 读取，免费
    function getGreeting() public view returns (string memory) {
        return gretting;
    }
}

contract WorldCupLottery {
    // 1. 状态变量(真正上链）：管理员、第几期、记录所有玩家、统计每个球队参与者、记录获奖者信息、参赛球队
    // 2. 核心方法：投票、开奖、领奖
    // 3. 辅助方法：获取奖金池金额、管理员地址、当前期数、参与人数、所有玩家、参赛球队

    // 管理员
    address public manager;
    
    //第几期
    uint8 public currRound;

    // 参赛球队
    string[] public countries = ["GERMANY", "FRANCH", "CHINA", "BRIZAL", "KOREA"];

    // mapping
    // mapping(第几期 => mapping(玩家地址 => 玩家的详情struct)）
    mapping (uint8 => mapping (address => Player)) public players;

    // mapping(第几期 => maping(中国 => address[张三，李四]))
    mapping (uint8 => mapping (Country => address[])) public countryToPlayers;

    // 张三 => 可以claim的数量
    mapping (address => uint256) public winnerVaults;

    // 没有被领取的奖励需要锁起来
    uint256 public lockAmt;

    struct Player {
        bool flag;

        // 一个玩家，可以同时投票多个国家，多票
        mapping (Country => uint) counts;
    }

    enum Country {
        GERMANY, FRANCH, CHINA, BRIZAL, KOREA
    }

    // 修饰器，做一些权限校验，参数校验
    modifier onlyManager {
        require(msg.sender == manager, "not authorized!");
        
        // 被修饰的逻辑
        _;
    }

    event TransferMgr(address _prev, address _newMgr);
    event Play(uint8 _round, address _player, uint8 _selected);
    event Finalize(uint8 _round, Country _selected);
    event ClaimReward(address _claimer, uint256 _amt);

    // 构造函数
    constructor() {
        // 交易的发起人是msg.sender,此时部署人就是manager
        manager = msg.sender;
    }

    // 转移manager
    function transferMgr(address _newMgr) public onlyManager {
        // require(msg.sender == manager, "not authorized!");
        address prev = manager;
        manager = _newMgr;
        emit TransferMgr(prev, manager);
    }

    // paly时，玩家需要转入 1ETH
    // 如果想在发起交易的时候，转入资金，那么合约的方法必须修饰为payable
    function paly(Country _selected) public payable {

        // 金额校验
        require(msg.value == 1 gwei, "invalid funds provided!"); 

        // 更新countries，
        // 往状态变量的数组中追加数据，使用push
        countryToPlayers[currRound][_selected].push(msg.sender);

        // 更新players
        // 获取Player结构
        // 更新数据
        Player storage player = players[currRound][msg.sender];
        player.counts[_selected] ++;

        console.log("selected:", uint8(_selected));
        
        emit Play(currRound, msg.sender, uint8(_selected));
    }

    // 开奖
    function finalize(Country _selected) public onlyManager {
        // require(msg.sender == manager, "not authoried!");

        // 找到所有的赢家  winners
        address[] memory winners = countryToPlayers[currRound][_selected];

        // 获取当前合约的可用金额
        uint256 currAvailBalance = getVaultBal() - lockAmt;

        // 计算每个人奖励多少
        for (uint i = 0; i < winners.length; i++) {
            address currWinner = winners[i];

            // 获取当前winner在下了多少注
            Player storage winner = players[currRound][currWinner];

            uint256 currCounts = winner.counts[_selected];

            // 统计这个winner该分的多少奖励
            uint amt = (currAvailBalance / countryToPlayers[currRound][_selected].length) * currCounts;
            console.log("currWinner:", currWinner, "reward:", amt);

            // 更新currWinner能够领取的金额
            winnerVaults[currWinner] += amt;
            lockAmt += amt;
        }

        emit Finalize(currRound, _selected);
    }

    // 领奖
    function claimReward() public {
        // 每个人都可以调用，但是只能领取属于自己的钱
        uint256 rewards = winnerVaults[msg.sender];
        require(rewards > 0, "nothing to claim!");

        // 给msg.sender转账
        // 使用 transfer方法进行转账：transfer，send（不用了），call（后面讲）
        // 合约给谁转账，就用谁调用transfer，如果转账失败，会进行revert，整个交易回滚
        // 交易是原子性的，完成，回归原始状态（消耗的手续费gas fee不会退回）
        payable(msg.sender).transfer(rewards);

        // 清零
        winnerVaults[msg.sender] = 0;

        // lockAmt减少
        lockAmt -= rewards;

        emit ClaimReward(msg.sender, rewards);
    }

    // 查看当前合约的资金数量
    function getVaultBal() public view returns (uint256){
        return address(this).balance;
    }
}
```



## 下次预告

1. 使用工程化来管理合约
2. 自动编译、部署、verify、单元测试、fork主网



## 资源链接

1. 详细知识点：https://github.com/dukedaily/solidity-expert
2. 快速添目标网络：https://chainlist.org/
3. 水龙头领取Goerli主币：https://goerlifaucet.com/
4. 一键领取多个水龙头，需要Twitter登录：https://faucet.paradigm.xyz/
5. 详细知识点托管在github：https://github.com/dukedaily/solidity-expert



加V入群：Adugii，公众号：阿杜在新加坡，一起抱团拥抱web3，下期见！

> 关于作者：国内第一批区块链布道者；2017年开始专注于区块链教育(btc, eth, fabric)，目前base新加坡，专注海外defi,dex,元宇宙等业务方向。